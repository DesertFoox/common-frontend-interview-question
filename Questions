تفاوت var، let و const:
- `var` استفاده می‌شود برای تعریف متغیر در قدیمی‌ترین نسخه‌های جاوااسکریپت. متغیرهای تعریف شده با `var` دارای scope نمی‌باشند و در حدود متن کد قابل دسترسی هستند.
- `let` و `const` در ECMAScript 6 (ES6) معرفی شدند. `let` و `const` دارای block scope هستند، به این معنی که فقط در داخل بلوکی که تعریف شده‌اند، قابل دسترسی هستند. تفاوت اصلی بین `let` و `const` در این است که مقدار `let` قابل تغییر است، در حالی که مقدار `const` ثابت است و نمی‌توان آن را تغییر داد.

مفهوم Hoisting:
Hoisting به معنای جابه‌جایی یا حرکت متغیرها و توابع به بالا در محیط اجرایی است. در جاوااسکریپت، متغیرها و توابع که با `var` تعریف شده‌اند، قبل از اجرای کد به بالا جابه‌جا می‌شوند. این به معنای این است که می‌توان متغیرها و توابع را قبل از تعریف استفاده کرد. با این حال، تنها اسم متغیرها و توابع جابه‌جا می‌شوند و نه مقدارهای اولیه آن‌ها.

مفهوم primitive value و reference value:
در جاوااسکریپت، primitive value شامل اعداد، رشته‌ها، بولین‌ها، undefined و null می‌شود. این مقادیر به صورت مستقیم ذخیره می‌شوند و به عنوان یک مقدار صفرمانند (by-value) کپی می‌شوند.
به عنوان مقابل، reference value شامل آبجکت‌ها، آرایه‌ها و توابع می‌شود. این مقادیر به صورت اشاره‌گر (reference) ذخیره می‌شوند و کپی شدن آن‌ها به صورت مستقیم صورت نمی‌گیرد. در واقع، مقدار یک reference value به نو

عی به مکان حافظه اشاره می‌کند و نه به مقدار واقعی.

چرا آرایه‌ها و آبجکت‌ها رفرنس‌تایپ هستند؟
دلیل اصلی این است که آرایه‌ها و آبجکت‌ها معمولاً داده‌های پیچیده‌تری هستند که نیاز به ذخیره سازی در یک مکان حافظه مشترک دارند. با استفاده از اشاره‌گرها، می‌توان به یک آبجکت یا آرایه در جاوااسکریپت ارجاع داد و در این صورت تغییرات در آن به صورت مستقیم روی اصل ذخیره شده اعمال می‌شود. این رفتار رفرنس‌تایپ در جاوااسکریپت باعث می‌شود تا تغییرات در یک متغیر مورد استفاده مستقیم بر روی سایر متغیرهایی که به همان مقدار اشاره می‌کنند، تاثیر بگذارد.

چگونگی انجام کپی کردن آبجکت؟
در جاوااسکریپت، کپی کردن یک آبجکت می‌تواند به دو صورت shallow copy و deep copy انجام شود:
- Shallow copy: در shallow copy، فقط اشاره‌گرها (references) از آبجکت اصلی به آبجکت کپی شده را کپی می‌کنیم و این کپی با آبجکت اصلی به صورت shallow ارتباط دارد. در نتیجه، تغییرات در آبجکت کپی شده ممکن است تغییراتی در آبجکت اصلی ایجاد کند.
- Deep copy: در deep copy، کل ساختار آبجکت به طور بازگشتی کپی می‌شود و هر تغییر در آبجکت کپی شده تاثیری بر آبجکت اصلی ندارد. برای انجام deep copy، می‌توان از روش‌هایی مانند استفاده از `JSON.parse(JSON.stringify(object))`، استفاده از کتابخانه‌های سمت کاربر مانند Lodash، یا پیاده

‌سازی تابع خودتان برای بازگشتی کردن کپی عمیق از آبجکت استفاده کرد.

تفاوت shallow copy و deep copy:
- Shallow copy فقط اشاره‌گرها (references) را کپی می‌کند و در نتیجه آبجکت کپی شده با آبجکت اصلی به صورت shallow ارتباط دارد. این بدان معناست که تغییرات در آبجکت کپی شده ممکن است تغییراتی در آبجکت اصلی ایجاد کند.
- Deep copy کل ساختار آبجکت به طور بازگشتی کپی می‌شود و هر تغییر در آبجکت کپی شده تاثیری بر آبجکت اصلی ندارد.

مفهوم پارادایم‌های برنامه‌نویسی (functional programming، OOP):
- Functional programming (برنامه‌نویسی تابعی) یک پارادایم برنامه‌نویسی است که بر پایه توابع محور است. در این روش، برنامه به صورت ترکیبی از توابع و عملیات روی داده‌ها توصیف می‌شود. ایده اصلی این پارادایم این است که توابع بدون تغییر وضعیت و با دریافت ورودی مشخص، خروجی مشخصی تولید کنند. تابع‌ها در این پارادایم به عنوان یک موجود مستقل و بدون وضعیت در نظر گرفته می‌شوند و تغییر وضعیت جهان برنامه را کمینه می‌کنند.
- Object-oriented programming (OOP) (برنامه‌نویسی شیءگرا) یک پارادایم برنامه‌نویسی است که بر پایه مفهوم اشیاء و روابط بین آن‌ها استوار است. در این پارادایم، برنامه به صورت مجموعه‌ای از اشیاء توصیف می‌شود که هر کدام ویژگی‌ها و رفتارهای خود را دارند. اشیاء می‌توانند از نوع‌های مختلف باشند و با یکدیگر در تعامل هستند. ا

صول مهم در OOP شامل انکاپسولیشن (encapsulation)، میراث (inheritance) و پلی‌مورفیسم (polymorphism) است.

تفاوت == و ===:
- `==` عملگر مساوی است و بررسی می‌کند که دو مقدار برابر هستند یا خیر. در صورت استفاده از `==`، ممکن است تبدیل نوع‌ها (type coercion) رخ دهد. بنابراین، در برخی موارد دو مقدار با انواع متفاوت نیز می‌توانند به عنوان برابر در نظر گرفته شوند.
- `===` عملگر مساوی سخت است و بررسی می‌کند که دو مقدار برابر هستند و همچنین هر دو نوع دقیقاً یکسان باشند. این عملگر از تبدیل نوع‌ها جلوگیری می‌کند و تنها در صورتی که دو مقدار هم از نظر مقدار و هم از نظر نوع یکسان باشند، به عنوان برابر در نظر گرفته می‌شوند.

مفهوم type coercion:
Type coercion یا تبدیل نوع‌ها، روند تبدیل یک نوع داده به نوع دیگر است. در جاوااسکریپت، این تبدیل نوع‌ها به صورت ضمنی (implicit) انجام می‌شود و ممکن است در برخی عملیات‌ها و مقایسه‌ها رخ دهد. برای مثال، در مقایسه دو مقدار از نوع‌های مختلف با استفاده از عملگر `==`، تبدیل نوع‌ها برای مقایسه صورت می‌گیرد. به عنوان مثال، عبارت `1 == '1'` به عنوان درست محسوب می‌شود، زیرا عبارت `'1'` به صورت ضمنی به عدد 1 تبدیل می‌شود.

مفهوم closure - کاربرد closure و use caseها؟
Closure یک مفهوم در جاوااسکریپت است که به معنای داشتن دسترسی توابع به متغیرهای محلی در scope خار

جی خود می‌باشد. یک closure تشکیل می‌شود وقتی یک تابع داخلی (inner function) دسترسی به متغیرهای تابع بیرونی (outer function) خود را داشته باشد.

کاربردهای Closure عبارتند از:
- مخفی کردن متغیرها و اطلاعات از دسترسی عموم.
- ساختن private methods و متغیرهای محافظت شده.
- ایجاد محیط‌های داده محلی برای توابع.
- مدیریت حالت‌های پایدار و پیچیده در برنامه‌نویسی.

مفهوم HoF:
Higher-order function (HoF) یک تابع است که یک تابع دیگر را به عنوان آرگومان می‌پذیرد و یا یک تابع را به عنوان خروجی برمی‌گرداند. به عبارت دیگر، تابعی که با توابع دیگر تعامل می‌کند یا آن‌ها را تولید می‌کند، یک HoF است. این قابلیت به برنامه‌نویس اجازه می‌دهد تا توابع را به عنوان داده‌ها بررسی، تغییر داده و به عنوان خروجی تولید کند. HoF می‌تواند از قابلیت‌هایی مانند انتزاع (abstraction)، تکرار (iteration) و کنترل جریان (flow control) بهره ببرد.

مفهوم event bubbling:
Event bubbling به معنای پخش رویداد است و در مدل رویدادهای DOM در جاوااسکریپت استفاده می‌شود. زمانی که یک رویداد به عنوان نتیجه‌ای از انجام یک عمل در المانی مشخص اتفاق می‌افتد، ابتدا رویداد به المان هدف ارسال می‌شود، سپس به المان والد آن و به صورت پیوسته به المان‌های والد بالاتر ارسال می‌شود. این روند ادامه پیدا می‌کند تا به المان ریشه (root) یا بالاترین المان مربوطه برسد.

مفهوم event capturing:
Event capturing یک مدل دیگر در مدل

 رویدادهای DOM است. در این مدل، رویداد از المان ریشه شروع شده و به صورت پیشرونده به المان هدف حرکت می‌کند. به این ترتیب، ابتدا رویداد به المان ریشه ارسال می‌شود و سپس به صورت پیوسته به المان‌های زیریابی (descendant) ارسال می‌شود تا به المان هدف برسد.

مفهوم کلاس‌ها و متد super:
در جاوااسکریپت، کلاس‌ها به عنوان یک بلوک سازماندهی شده از کد و ویژگی‌های مرتبط (properties) و عملیات (methods) برای ایجاد شیء (object) استفاده می‌شوند. کلاس‌ها می‌توانند ویژگی‌ها و رفتارهای خود را تعریف کنند و به عنوان الگویی برای ایجاد شیء استفاده شوند.

کلمه کلیدی super در کلاس‌ها به معنای ارجاع به کلاس والد (superclass) است. با استفاده از super می‌توان به ویژگی‌ها و متدهای کلاس والد دسترسی پیدا کرد. این امکان را به برنامه‌نویس می‌دهد تا ویژگی‌ها و رفتارهای کلاس والد را در کلاس فرزند به کار بگیرد و در صورت نیاز، آن‌ها را تغییر دهد یا به آن‌ها عملکرد جدیدی اضافه کند.

مفهوم execution context:
Execution context به معنای محیط اجرایی یک کد در زمان اجرا است. هر بار که برنامه به یک تابع ورودی می‌کند، یک execution context برای آن تابع ساخته می‌شود. Execution context شامل اطلاعاتی مانند متغیرها، آرگومان‌ها، تابع‌های دیگر در اسکوپ مورد نظر، اشاره‌گر this و مقدار بازگشتی تابع است.

Execution context به صورت پشته‌ای (stack) سازماندهی می‌شود، که به آن استک اجرا (execution stack) یا stack call هم گفت

ه می‌شود. هنگامی که تابعی فراخوانی می‌شود، execution context مربوط به آن در بالای استک قرار می‌گیرد و زمانی که تابع اجرا خاتمه یابد، execution context متناظر آن از استک حذف می‌شود.

تفاوت تابع‌های arrow function و regular functions:
تفاوت‌های عمده بین arrow function و regular function عبارتند از:

1. نحوه تعریف: تابع‌های arrow با استفاده از عملگر => تعریف می‌شوند، در حالی که regular functions با استفاده از کلیدواژه function تعریف می‌شوند.

2. مقدار `this`: تابع‌های arrow به طور خودکار مقدار `this` را از محدوده اطراف خود به ارث می‌برند، در حالی که در regular functions، مقدار `this` بر اساس روش فراخوانی تابع تعیین می‌شود.

3. مقدار `arguments`: تابع‌های arrow متغیر `arguments` را ندارند، در حالی که در regular functions می‌توان از `arguments` برای دسترسی به آرگومان‌های فراخوانی شده استفاده کرد.

4. محدوده `this`: تابع‌های arrow محدوده `this` را از محدوده بیرونی خود به ارث می‌برند و آن را تغییر نمی‌دهند، در حالی که در regular functions محدوده `this` به صورت پویا توسط روش فراخوانی تابع تعیین می‌شود.

مفهوم prototype در جاوااسکریپت:
در جاوااسکریپت، هر آبجکت (object) یک پروتوتایپ (prototype) دارد که مانند یک الگو برای آن آبجکت عمل می‌کند. پروتوتایپ شامل ویژگی‌ها و متدهایی است که به آبجکت‌هایی که بر اساس آن ایجاد می‌شوند، به ارث داده می‌شود.

هر آبجکت در جاوااسکریپت ارتباطی با پروتوتایپ خود دارد. وقتی یک ویژگی یا متد را

 در یک آبجکت جستجو می‌کنیم، اگر در آن آبجکت وجود نداشته باشد، جستجو به پروتوتایپ آن آبجکت انتقال پیدا می‌کند. این روند تا زمانی که موردی پیدا شود یا به پایان برسد، ادامه می‌یابد.

این ویژگی ارث‌بری با پروتوتایپ (prototype-based inheritance) در جاوااسکریپت را امکان می‌دهد تا آبجکت‌ها را به صورت پویا و در زمان اجرا ارتباط دهیم و ویژگی‌ها و رفتارهای مشترک را بین آن‌ها به ارث ببریم.

مفهوم threads:
Threads به معنای رشته‌های اجرایی مستقل در یک برنامه است. هر رشته (thread) یک جریان اجرایی است که به صورت همزمان با سایر رشته‌ها در حال اجراست. برنامه‌های چند رشته‌ای می‌توانند به صورت همزمان چندین وظیفه را انجام دهند و فرآیند‌های مختلف را به صورت همزمان اجرا کنند.

مفهوم event loop:
Event loop به معنای حلقه رویداد است و در محیط اجرایی جاوااسکریپت (مانند مرورگر) وظیفه مدیریت رویدادها و اجرای کدهای مربوط به آن‌ها را دارد. در حالت عادی، برنامه‌های جاوااسکریپت به صورت همروند اجرا نمی‌شوند و تنها یک رشته اجرایی دارند. Event loop در این حالت، رویدادهای رخ داده شده را در صف قرار می‌دهد و کدهای مربوط به آن‌ها را به ترتیب اجرا می‌کند. این فرآیند تا زمانی که صف رویداد‌ها خالی شود، ادامه می‌یابد.

مفهوم scope chain:
Scope chain به معنای زنجیره دسترسی به متغیرها در یک برنام

ه است. در جاوااسکریپت، هر بلاک (block)، تابع یا محدوده‌ای که متغیرها در آن تعریف می‌شوند، یک scope ایجاد می‌کند. هر scope دارای یک زنجیره از scope‌های والد است که به آن‌ها می‌توان در صورت نیاز دسترسی داشت.

وقتی یک متغیر در یک بلاک مورد استفاده قرار می‌گیرد، ابتدا در scope محلی بررسی می‌شود و سپس در scope والد و به صورت پیوسته در scope‌های والد بالاتر تا زمانی که متغیر پیدا شود یا به پایان برسد. این فرآیند به عنوان scope chain شناخته می‌شود و متغیرها در scope‌های محلی و والد قابل دسترسی هستند.

تفاوت متدهای bind و apply:
متد bind و apply به همراه call به ما اجازه می‌دهند تا یک تابع را با یک مقدار خاص برای متغیر this فراخوانی کنیم. تفاوت‌های اصلی بین bind و apply عبارتند از:

- bind: با استفاده از متد bind می‌توان یک تابع جدید ایجاد کرد که this آن تابع به یک مقدار معین بایند شده است. تابع جدید، هنگام فراخوانی، مقدار this معین شده را استفاده خواهد کرد.

- apply: متد apply به شما امکان می‌دهد تا تابع را فراخوانی کنید و مقادیر آرگومان‌های آن را در قالب آرایه به آن بدهید. همچنین، می‌توانید مقدار this را نیز به آن منتقل کنید.

توضیحات درباره reduce، map، filter:
- reduce: متد reduce برای کاهش یک آرایه به یک مقدار یکتا به کار می‌رود. با استفاده از reduce، می‌توانید به طور تکراری بر روی آیتم‌های آرایه عملیاتی انجام دهید و نتیجه بینایی را به صورت

 تجمعی به دست آورید.

- map: متد map برای ایجاد یک آرایه جدید با تغییر دادن هر آیتم از آرایه اصلی استفاده می‌شود. با استفاده از map، می‌توانید تابعی را روی هر آیتم اجرا کرده و نتایج را در آرایه جدیدی جمع آوری کنید.

- filter: متد filter برای ایجاد یک آرایه جدید با حذف آیتم‌هایی که شرط مورد نظر را ندارند، استفاده می‌شود. با استفاده از filter، می‌توانید فقط آیتم‌هایی را دریافت کنید که شرط داده شده را برآورده می‌کنند.

فلسفه virtual DOM:
Virtual DOM به معنای یک نمایشگر (representation) مجازی از DOM است که توسط فریمورک‌های مانند React استفاده می‌شود. واقعیت این است که عملیات مستقیم روی DOM سنگین و هزینه‌بر است. به جای این که تغییرات را مستقیماً بروی DOM اعمال کنیم، فریمورک‌هایی مانند React از یک نمایشگر مجازی برای تغییرات استفاده می‌کنند. این نمایشگر مجازی (Virtual DOM) تغییرات را در یک ساختار داده در حافظه اعمال می‌کند و سپس با نمایشگر واقعی DOM مقایسه می‌شود تا تغییرات مورد نیاز به صورت کارآمدی اعمال شود. این فلسفه می‌تواند پرفورمنس و سرعت برنامه را بهبود بخشد، زیرا تعداد کمتری از عملیات مستقیم بر روی DOM انجام می‌شود.

لایف‌سایکل‌های کامپوننت‌های ری‌اکت:
لایف‌سایکل‌ها در ری‌اکت مراحلی هستند که یک کامپوننت در طول زندگی خود از آن‌ها عبور می‌کند. این مراحل شامل:

1. Mounting:

 کامپوننت به DOM اضافه می‌شود.
   - constructor: مرحله ساخت کامپوننت و تعیین وضعیت اولیه.
   - render: ایجاد و بازگشت JSX مربوط به کامپوننت.
   - componentDidMount: فراخوانی پس از قرار گرفتن کامپوننت در DOM.

2. Updating: کامپوننت بروزرسانی می‌شود.
   - render: ایجاد و بازگشت JSX مربوط به کامپوننت.
   - componentDidUpdate: فراخوانی پس از بروزرسانی کامپوننت و به روزرسانی DOM.

3. Unmounting: کامپوننت از DOM حذف می‌شود.
   - componentWillUnmount: فراخوانی قبل از حذف کامپوننت از DOM.

4. Error Handling: مدیریت خطاها در کامپوننت.
   - componentDidCatch: فراخوانی در صورت بروز خطا در زیرمجموعه‌های کامپوننت.

شبیه‌سازی چند لایف‌سایکل مربوط به کلاس کامپوننت‌ها در فانکشنال کامپوننت‌ها، مثلاً شبیه‌سازی componentWillUnmount:
در کلاس کامپوننت‌ها، lifecycle method به نام componentWillUnmount برای انجام عملیات قبل از حذف کامپوننت از DOM وجود دارد. اما در فانکشنال کامپوننت‌ها، این lifecycle method مستقیماً وجود ندارد.

به منظور شبیه‌سازی عملکرد componentWillUnmount در یک فانکشنال کامپوننت، می‌توان از Hook useEffect با یک تابع cleanup استفاده کرد. در این تابع cleanup، عملیاتی که قبل از حذف کامپوننت انجام می‌شود، انجام می‌شود. به عنوان مثال:

```javascript
import React, { useEffect } from 'react';

const MyComponent = () => {
  useEffect(() => {
    // componentDidMount

    return () => {
      // componentWillUnmount
      // عملیات قبل از حذف کامپوننت
    };
  }, []);

  // رندر کامپوننت
  return <div>My Component</div>;
};
```

نام بردن انواع هوک‌های ری‌اکت:
- useState: برای استفاده از وضعیت مح

لی در فانکشنال کامپوننت.
- useEffect: برای اجرای عملیات‌های اثربخش در فانکشنال کامپوننت بر اساس تغییرات در وضعیت یا درایه‌های ورودی.
- useContext: برای دسترسی به مقدار context در فانکشنال کامپوننت.
- useReducer: برای مدیریت وضعیت پیچیده با استفاده از reducer در فانکشنال کامپوننت.
- useRef: برای دسترسی به مقدار مربوط به رندر قبلی در فانکشنال کامپوننت.
- useMemo: برای حافظه‌بندی نتیجه محاسبات محاسبه‌ای در فانکشنال کامپوننت.
- useCallback: برای حافظه‌بندی تابع‌ها در فانکشنال کامپوننت.
- useLayoutEffect: برای اجرای عملیات‌های اثربخش در فانکشنال کامپوننت به صورت همزمان با ایجاد و به روزرسانی DOM.
- useMemoOne: برای حافظه‌بندی نتایج محاسبات محاسبه‌ای با استفاده از memoization در فانکشنال کامپوننت.

مفهوم کد اسپلیتینگ:
Code splitting به معنای جدا کردن کد بزرگ به بخش‌های کوچکتر برای بارگیری بهینه‌تر است. در جاوااسکریپت، وقتی یک برنامه جاوااسکریپت بزرگ را بارگیری می‌کنید، کل کد باید دانلود شود حتی اگر بخشی از کد توسط کاربر استفاده نشود. با استفاده از code splitting، می‌توان کد را به بخش‌های کوچکتر تقسیم کرد و فقط بخشی از کد که واقعاً نیاز است را بارگیری کرد.

با استفاده از ابزارهای مانند Webpack یا React Suspense، می‌توان کدها را به بخش‌های کوچکتر تقسیم کرده و در زمان لزوم فقط بخش‌های لازم را بارگیری کرد. این موضوع می‌تواند زمان بارگیری

 را کاهش داده و عملکرد برنامه را بهبود بخشد.

چگونگی بهبود پرفورمنس کامپوننت‌ها؟ روش‌های محتمل:

- استفاده از React.memo: با استفاده از این هوک، می‌توان کامپوننت‌ها را به صورت حافظه‌بندی شده رندر کرد و فقط زمانی که ورودی‌ها تغییر کنند، رندر جدید را انجام داد.

- استفاده از useCallback: با استفاده از این هوک، می‌توان توابع را به صورت حافظه‌بندی شده تعریف کرد تا در هر رندر مجدداً ایجاد نشوند، مگر این که ورودی‌ها تغییر کنند.

- استفاده از useMemo: با استفاده از این هوک، می‌توان نتایج محاسباتی را به صورت حافظه‌بندی شده ذخیره کرد تا در رندرهای بعدی استفاده شوند.

- بهینه‌سازی عملکرد کدها: می‌توان بهینه‌سازی کدها و الگوریتم‌ها برای کاهش زمان اجرا و استفاده بهینه از منابع راه‌اندازی.

- استفاده از Lazy Loading: با استفاده از تکنیک Lazy Loading، می‌توان قسمت‌هایی از برنامه را برای بارگیری به تأخیر انداخت تا زمانی که نیاز دارند و اجرای برنامه را بهبود بخشید.

- بهینه‌سازی استفاده از شیوه‌های استایل: استفاده از شیوه‌های مناسب در استایل‌دهی می‌تواند رندر و بازسازی مجدد کامپوننت‌ها را کاهش دهد.

- Memoization: با استفاده از تکنیک memoization، می‌توان نتایج محاسبات را ذخیره کرده و در صورت تکرار، مقدار ذخیره شده را استفاده کرد.

- استفاده از خصیصه shouldComponentUpdate در کامپوننت‌های کلاسی.

این روش‌ها تنها نم

ونه‌ای از روش‌های بهبود پرفورمنس هستند و بهتر است با توجه به مورد خاص برنامه و شرایط استفاده، روش‌های مناسب را اعمال کنید.
